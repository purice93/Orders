
Question 1

(a) (i)
	随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，
	称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。
	时间复杂度不包括这个函数的低阶项和首项系数
	(ii)
	5n^2+11n+9：
	项的阶数有：5n^2>11n>9 
	去除低阶项的5n^2
	去除首项系数为：n^2	
	即结果为：O(n^2)

(b)
	选择排序：每次从待排序数组里选择一个最小(或最大)的数字，放到数组最前面
	时间复杂度为n^2：每次从数组中遍历，找到一个最小的数字，为n；需要n次这样的遍历；即n*n=n^2

(c)


Question 2
	ok!
	

Question 3:
	(a)
	描述：判断一个程序能否在有限的时间内结束或者死循环
	证明：如果存在一个判断停机问题的程序H（H需要的输入是一个程序），我们再构造一个新的程序K，
	这个程序调用H但是与H的输出正好相反：如果K的输入经H判断为停机，则K不停机；如果K的输入经H判断为不停机，
	则K停机。现在矛盾出现了：如果我们把K输入K（即用H判断对于程序K，给出输入为K），那么K停机么？
	如果按逻辑推演，答案应该是：如果K不停机则K停机；如果K停机则K不停机。矛盾出现了。
	唯一解决矛盾的解释是：不存在这样万能的H。
	(b)(c)：
	草稿纸上
	
Question 4:
	(a)
	public int getNumOfNonLetters(BinaryTree<Character> bt) {
        int num = 0;
        int i = 0;
        if (bt.isEmpty()) {
            return num;
        } else {
            if (Character.isLetter(bt.rootValue())) {
                i = 1;
            }
            num = getNumOfNonLetters(bt.leftChild())+1;
            num = num+getNumOfNonLetters(bt.rightChild());
        }
        return num;
    }
	
	(b)稿纸
	

	
	

2017
Question 1

(a) (i)
	随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，
	称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。
	时间复杂度不包括这个函数的低阶项和首项系数
	(ii)
	5n^2+11n+9：
	项的阶数有：5n^2>11n>9 
	去除低阶项的5n^2
	去除首项系数为：n^2	
	即结果为：O(n^2)

(b)
	初始状态，将待排序数组分为已排序和未排序两部分，然后，遍历，将未排序序列中的元素逐一插入到已排序的序列中。
	复杂度：
		平均复杂度：第一步遍历整个数组n，然后对于每一个数，插入到之前的已排序数组，需要对比已排序数组n，即复杂度为n^2
		最好复杂度：当元是数组已经有序，则只需要遍历一次，每次只对比一个数，复杂度为n=n*1
(c)
	不可计算函数即：对于一个问题，无法给出确切的解。
	说明：有比如：有一个函数集合B（即这个集合B是函数f的集合），并且B不是空集，也不是全部函数f，那么随机程序P是否属于B是不可计算的。
	
	
